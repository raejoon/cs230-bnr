#!/usr/bin/python3
import numpy as np
import random
import tensorflow as tf
import keras.models as models
import keras.layers as layers


random.seed(0)

def load_data(npy_file):
    """ Load data from file.
    Note that npy file generated by Ben's code has the following shape.
    (num_timsteps, num_blocks, num_asts)
    
    Returns:
    all_matrix (np.array): (num_asts, num_timesteps, num_blocks) data set
    """
    orig_mat = np.load(npy_file)
    orig_mat = np.swapaxes(orig_mat, 0, 1)
    orig_mat = np.swapaxes(orig_mat, 0, 2)
    return orig_mat


def create_validation_matrix(all_matrix):
    """ Create a matrix representing next block of each timestep of each AST.
    
    If data matrix is X and validation matrix is Y, Y[a,t,:] = X[a,t+1,:]
    The last timestep needs to predict the end of a AST, so will be
        [0, 0, ..., 0, 1]

    Returns:
    validation_matrix (np.array):
        (num_asts, num_timesteps, num_blocks) validation matrix
    """
    num_asts = all_matrix.shape[0]
    num_timesteps = all_matrix.shape[1]

    validation_matrix = np.zeros(all_matrix.shape)
    for t in range(num_timesteps - 1):
        validation_matrix[:,t,:] = all_matrix[:,t+1,:]

    validation_matrix[:,num_timesteps-1,-1] = np.ones(num_asts)
    return validation_matrix


def split_data(all_matrix):
    """ Split data set into 3 groups, training/dev/test set.
    
    Split them in axis=0.
    Randomly pick 1% of ASTs and assign them to dev set.
    Randomly pick another 1% of ASTS and assign them to test set.
    
    Parameters:
    all_matrix (np.array): (num_asts, num_timesteps, num_blocks) data set

    Returns:
    train_matrix (np.array)
    dev_matrix (np.array)
    test_matrix (np.array)
    """
    num_asts = np.shape(all_matrix)[0]  
    test_set_size = num_asts // 100
    
    data_indices = list(range(num_asts))
    random.shuffle(data_indices)
    
    train_matrix = all_matrix[2*test_set_size:]
    dev_matrix = all_matrix[:test_set_size]
    test_matrix = all_matrix[test_set_size:2*test_set_size]
    return train_matrix, dev_matrix, test_matrix


def random_prediction(input_matrix):
    """ Returns accuracy for blind random prediction of the next block.
    
    Parameters:
    input_matrix (np.array): (num_asts, num_timesteps, num_blocks) data set

    Returns:
    (float) prediction accuracy
    """
    
    num_asts, num_timesteps, num_blocks = np.shape(input_matrix)

    decoded_input = np.zeros((num_asts, num_timesteps))
    predictions = np.zeros(np.shape(decoded_input))

    # One-hot encoding into integers
    for ast_id in range(num_asts):
        indices = np.array(
                [np.where(r == 1)[0][0] for r in input_matrix[ast_id, :, :]])
        end_block_mask = (indices == (num_blocks - 1))
        
        end_block_fill = (num_blocks - 1) * np.ones((1, num_timesteps))
        random_fill = np.random.randint(num_blocks, size=(1, num_timesteps))
        
        predictions[ast_id, :] = end_block_mask * end_block_fill + \
                (end_block_mask == False) * random_fill
        print(indices, end_block_mask)
        print(indices, predictions[ast_id, :])

    # Decode validation matrix
    validation_matrix = create_validation_matrix(input_matrix) 
    decoded_output = np.zeros((num_asts, num_timesteps))
    for ast_id in range(num_asts):
        indices = [np.where(r == 1)[0][0] for r in input_matrix[ast_id, :, :]]
        decoded_output[ast_id, :] = indices
    
    # Calculate accuracy
    denominator = num_asts * num_timesteps
    numerator = np.sum(1 * (decoded_output == predictions))
    
    return predictions, numerator / denominator


def test_random_prediction():
    np.random.seed(3)
    num_asts = 2
    num_timesteps = 3
    num_blocks = 4
    
    input_matrix = np.zeros((num_asts, num_timesteps, num_blocks))
    input_matrix[0,:,:] = [[1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
    input_matrix[1,:,:] = [[0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 1]]
    
    predictions, accuracy = random_prediction(input_matrix)
    assert(np.all(predictions > -1))
    assert(np.all(predictions < num_blocks))
    assert(predictions[0, 2] == num_blocks - 1)
    assert(np.all(predictions[1, 1:2] == num_blocks - 1))
    print(accuracy)


def create_model(num_timestep, num_blocks):
    """ Returns LSTM model for predicting next block in a given AST and a
    timestep
    """
    hidden_size = 128
    dropout_p = 0.5
    
    model = models.Sequential()
    
    #Add LSTM layer with 128 hidden units, tanh nonlinearity
    model.add(layers.LSTM(hidden_size, 
                          activation='tanh',
                          return_sequences=True,
                          input_shape=(num_timestep, num_blocks)))
    
    #Add Dropout
    #What about rescalling?, we shouuld add scale up to avoid modifying it during test time
    model.add(layers.Dropout(dropout_p))
    
    #Add Dense layer
    model.add(layers.Dense(num_blocks,
                           activation='softmax'))
    
    #Configure the learning process
    model.compile(loss="categorical_crossentropy",
                  optimizer="adam",
                  metrics=["accuracy"])
    
    model.summary()
    return model


def train_model(train_matrix, train_labels):
    """ Train the model with the input matrix. """
    
    model.fit(train_matrix, train_labels, epochs=5)


def test_nn_framework():
    # Input: (M x T x B) matrix representing blocks in all ASTs
    all_matrix = load_data("./data-created/q4_array_of_ast_matrices.npy")
    validation_matrix = create_validation_matrix(all_matrix)
    print(all_matrix.shape)
    print(validation_matrix.shape)

    # Split into training/dev/test set
    train_matrix, dev_matrix, test_matrix = split_data(all_matrix)
    print(train_matrix.shape)
    print(dev_matrix.shape)
    print(test_matrix.shape)

    # Create model
    num_timesteps = all_matrix.shape[1]
    num_blocks = all_matrix.shape[2]
    model = create_model(num_timesteps, num_blocks)

    # train_matrix model
    #train_matrix = all_matrix[0, :, :]
    #train_labels = validation_matrix[0, :, :]    
    #train_model(train_matrix, train_labels)
    train_model(all_matrix, validation_matrix)


if __name__=="__main__":
    test_random_prediction()
